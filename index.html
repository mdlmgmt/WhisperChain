<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WhisperChain</title>
    <style>
        :root { 
            --bg: #ffffff; 
            --text: #000000; 
            --border: #e0e0e0; 
            --accent: #333333;
        }
        body { 
            background: var(--bg); color: var(--text); 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            margin: 0; padding: 0; 
            height: 100vh; display: flex; flex-direction: column;
        }

        /* HEADER */
        header {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border);
            display: flex; justify-content: space-between; align-items: center;
        }
        .brand { font-weight: 700; font-size: 1rem; letter-spacing: -0.5px; }
        .panic-btn { cursor: pointer; font-size: 1.2rem; color: #999; }
        .panic-btn:hover { color: #000; }

        /* INPUT AREA (TOP) */
        #composer {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            display: flex; gap: 10px; align-items: center;
        }
        input {
            flex: 1; border: none; background: #f5f5f5; color: #000;
            padding: 12px 15px; border-radius: 6px; outline: none;
            font-family: monospace; text-transform: uppercase; font-size: 1rem;
        }
        input::placeholder { color: #ccc; }
        input:focus { background: #eee; }
        
        .send-btn {
            background: #000; color: #fff; border: none; border-radius: 6px;
            padding: 12px 20px; font-weight: 600; cursor: pointer;
            font-size: 0.9rem;
        }
        .send-btn:disabled { background: #ccc; cursor: default; }

        /* FEED */
        #feed {
            flex: 1; overflow-y: auto; padding: 20px;
            display: flex; flex-direction: column; gap: 8px;
        }
        
        .msg-row {
            padding: 8px 0;
            border-bottom: 1px solid #f9f9f9;
            display: flex; gap: 10px; align-items: baseline;
            animation: fadeIn 0.2s ease;
        }
        .msg-time { font-size: 0.7rem; color: #999; font-family: monospace; min-width: 40px; }
        .msg-text { font-size: 0.95rem; font-weight: 500; letter-spacing: 0.5px; }
        .msg-row.sys { justify-content: center; color: #999; font-size: 0.8rem; font-style: italic; border:none;}

        /* STATUS & VIZ */
        #status {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: #000; color: #fff; padding: 6px 16px; border-radius: 20px;
            font-size: 0.75rem; opacity: 0; transition: 0.2s; pointer-events: none;
            display: flex; gap: 8px; align-items: center;
        }
        #status.active { opacity: 1; bottom: 30px; }
        
        #viz { position: fixed; top: 0; left: 0; width: 100%; height: 2px; z-index: 99; pointer-events: none; }

        /* INIT BUTTON */
        #initOverlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #fff; display: flex; align-items: center; justify-content: center;
            z-index: 50;
        }
        .activate-btn {
            background: #fff; border: 1px solid #000; padding: 15px 30px;
            font-weight: 600; cursor: pointer; transition: 0.2s;
        }
        .activate-btn:hover { background: #000; color: #fff; }

        /* CALCULATOR DISGUISE */
        #calcDisguise {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: #fff; color: #000; z-index: 9999;
            display: none; flex-direction: column; font-family: sans-serif;
        }
        .calc-screen { background: #f0f0f0; color: #000; height: 150px; width: 100%; font-size: 4rem; text-align: right; padding: 30px; box-sizing: border-box; font-weight: 300; }
        .calc-grid { display: grid; grid-template-columns: repeat(4, 1fr); height: 100%; }
        .calc-btn { border: 1px solid #f0f0f0; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; background: #fff; cursor: pointer; color: #333; }
        .calc-btn.orange { background: #ff9f0a; color: #fff; border:none; }
        .calc-btn.grey { background: #e5e5e5; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>

    <!-- DISGUISE -->
    <div id="calcDisguise">
        <div class="calc-screen">0</div>
        <div class="calc-grid">
            <div class="calc-btn grey">AC</div><div class="calc-btn grey">+/-</div><div class="calc-btn grey">%</div><div class="calc-btn orange">รท</div>
            <div class="calc-btn">7</div><div class="calc-btn">8</div><div class="calc-btn">9</div><div class="calc-btn orange">ร</div>
            <div class="calc-btn">4</div><div class="calc-btn">5</div><div class="calc-btn">6</div><div class="calc-btn orange">-</div>
            <div class="calc-btn">1</div><div class="calc-btn">2</div><div class="calc-btn">3</div><div class="calc-btn orange">+</div>
            <div class="calc-btn" style="width:200%">0</div><div class="calc-btn">.</div><div class="calc-btn orange" onclick="togglePanic()">=</div>
        </div>
    </div>

    <canvas id="viz"></canvas>

    <header>
        <div class="brand">WhisperChain</div>
        <div class="panic-btn" onclick="togglePanic()">รท</div>
    </header>

    <div id="composer">
        <input type="text" id="msgInput" maxlength="10" placeholder="10 CHAR LIMIT..." autocomplete="off">
        <button class="send-btn" id="sendBtn" onclick="transmit()">Send</button>
    </div>

    <div id="feed">
        <!-- Messages appear here -->
    </div>

    <div id="status">
        <span id="statusTxt">Receiving...</span>
        <span id="statusBuffer" style="font-family:monospace; color:#ccc"></span>
    </div>

    <div id="initOverlay">
        <button class="activate-btn" onclick="startSystem()">Connect Audio</button>
    </div>

<script>
/**
 * WHISPERCHAIN v2 - Handshake Protocol
 * Acknowledge-based character transmission
 */

const CFG = {
    freq: { ack: 17500, pilot: 18500, b0: 19000, b1: 19500 },
    baud: 50,     // Speed of bits
    fft: 2048,
    ackDur: 400   // Duration to play ACK tone
};

const CHARSET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 .!?"; 

let ctx, analyser, mic, micAnalyser;
let state = "IDLE"; // IDLE, TX_PULSE, TX_WAIT, RX_SCAN, RX_READ
let ambientNoise = 0;

// TX Queue Variables
let txQueue = "";
let txSeq = 0; // Sequence bit (0 or 1) to distinguish duplicate chars
let txRetryTimer = null;

// RX Variables
let rxLastSeq = -1; // Track last sequence to ignore duplicates

function togglePanic() { 
    const d = document.getElementById('calcDisguise'); 
    d.style.display = d.style.display==='flex'?'none':'flex'; 
    document.title = d.style.display==='flex'?'Calculator':'WhisperChain';
}

async function startSystem() {
    try {
        ctx = new (window.AudioContext || window.webkitAudioContext)();
        analyser = ctx.createAnalyser(); analyser.fftSize = CFG.fft; analyser.connect(ctx.destination);
        
        const s = await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:false,noiseSuppression:false,autoGainControl:false}});
        mic = ctx.createMediaStreamSource(s); micAnalyser = ctx.createAnalyser(); micAnalyser.fftSize = CFG.fft; micAnalyser.smoothingTimeConstant=0.2; mic.connect(micAnalyser);
        
        document.getElementById('initOverlay').style.display = 'none';
        addMsg("System", "Protocol v2 Active.");
        
        // Calibrate Noise Floor
        let cal = 0;
        const calInt = setInterval(() => {
            cal++;
            const lvl = getEnergy(CFG.freq.pilot);
            if(cal > 20) {
                ambientNoise = Math.max(5, lvl * 1.5);
                clearInterval(calInt);
                startLoop(); 
            }
        }, 50);

        drawViz();
    } catch(e) { alert("Microphone access required."); }
}

// --- MAIN LOOP ---
function startLoop() {
    setInterval(() => {
        if(state === "RX_SCAN") {
            // 1. Look for Incoming Char Pilot
            if(getEnergy(CFG.freq.pilot) > ambientNoise * 1.5) {
                state = "RX_READ";
                setStatus("Detecting...", true);
                setTimeout(() => readBits(), CFG.baud * 1.5); // Wait for header to clear
            }
        }
        
        if(state === "TX_WAIT") {
            // 2. Look for ACK from Receiver
            const ackLvl = getEnergy(CFG.freq.ack);
            if(ackLvl > ambientNoise * 1.3) {
                console.log("ACK RECEIVED");
                clearTimeout(txRetryTimer);
                // Success! Move to next char
                txQueue = txQueue.substring(1);
                txSeq = 1 - txSeq; // Flip sequence
                if(txQueue.length > 0) {
                    setTimeout(pulseNextChar, 200);
                } else {
                    finishTx();
                }
            }
        }
    }, 20);
    state = "RX_SCAN";
}


// --- TRANSMISSION LOGIC ---
function transmit() {
    if(!ctx) return;
    const inp = document.getElementById('msgInput');
    const txt = inp.value.toUpperCase().substr(0,10);
    if(!txt) return;

    inp.value = "";
    addMsg("Me", txt);
    
    // Prepare Queue
    txQueue = txt;
    txSeq = 0;
    
    // UI Update
    const btn = document.getElementById('sendBtn');
    btn.disabled = true; btn.innerText = "Sending...";
    
    pulseNextChar();
}

function finishTx() {
    state = "RX_SCAN";
    setStatus("", false);
    const btn = document.getElementById('sendBtn');
    btn.disabled = false; btn.innerText = "Send";
}

function pulseNextChar() {
    if(txQueue.length === 0) return;
    
    state = "TX_PULSE"; // Block RX while sending
    const char = txQueue[0];
    setStatus(`Sending "${char}"...`, true);

    // Encode: [Seq Bit] + [6 Bit Char Index]
    let idx = CHARSET.indexOf(char); if(idx === -1) idx = 36;
    const bits = txSeq.toString() + idx.toString(2).padStart(6, '0');
    
    const t = ctx.currentTime;
    let tPtr = t;

    // Play Pilot
    playTone(CFG.freq.pilot, tPtr, 0.1); 
    tPtr += 0.1;

    // Play Bits
    for(let i=0; i<bits.length; i++) {
        playTone(bits[i]==='1'?CFG.freq.b1:CFG.freq.b0, tPtr, CFG.baud/1000);
        tPtr += (CFG.baud/1000);
    }

    // Schedule Switch to Listening Mode
    const duration = (tPtr - t) * 1000;
    setTimeout(() => {
        state = "TX_WAIT"; // Start listening for ACK
        // Retry logic if no ACK received within 1.5s
        txRetryTimer = setTimeout(pulseNextChar, 1500); 
    }, duration + 50);
}


// --- RECEPTION LOGIC ---
function readBits() {
    // Read 7 bits (1 Seq + 6 Data)
    let bits = "";
    let readCount = 0;
    
    const reader = setInterval(() => {
        const e0 = getEnergy(CFG.freq.b0);
        const e1 = getEnergy(CFG.freq.b1);
        
        if(e1 > e0) bits += "1"; else bits += "0";
        readCount++;

        // Visualize
        document.getElementById('statusBuffer').innerText = bits;

        if(readCount >= 7) {
            clearInterval(reader);
            processReceivedBits(bits);
        }
    }, CFG.baud);
}

function processReceivedBits(bits) {
    // Parse
    const seq = parseInt(bits[0]);
    const val = parseInt(bits.substring(1), 2);
    const char = CHARSET[val] || "?";

    // BLAST ACK NOW (Regardless of whether it's duplicate)
    // We confirm receipt so the sender stops shouting at us
    sendAck();

    // Logic: Only display if Sequence ID flipped
    if(seq !== rxLastSeq) {
        addMsg("Peer", char);
        rxLastSeq = seq;
    } else {
        console.log("Duplicate packet ignored, but ACK sent.");
    }

    // Return to scanning
    setTimeout(() => { 
        state = "RX_SCAN"; 
        setStatus("", false); 
    }, CFG.ackDur + 100);
}

function sendAck() {
    state = "TX_PULSE"; // Block scanning
    setStatus("ACK Sent", true);
    playTone(CFG.freq.ack, ctx.currentTime, CFG.ackDur/1000);
}

// --- UTILS ---
function addMsg(user, text) {
    const f = document.getElementById('feed');
    // Combine with last message if same user (typing effect)
    const last = f.firstElementChild;
    if(last && !last.classList.contains('sys') && user !== "System" && last.dataset.user === user) {
        const txtDiv = last.querySelector('.msg-text');
        txtDiv.innerText += text;
    } else {
        const d = document.createElement('div');
        d.className = user==="System" ? "msg-row sys" : "msg-row";
        if(user!=="System") d.dataset.user = user;
        const time = new Date().toLocaleTimeString([], {hour12:false, hour:'2-digit', minute:'2-digit'});
        if(user==="System") d.innerHTML = text;
        else d.innerHTML = `<div class="msg-time">${time}</div><div class="msg-text">${text}</div>`;
        f.prepend(d);
    }
}

function setStatus(txt, active) {
    const s = document.getElementById('status');
    document.getElementById('statusTxt').innerText = txt;
    if(!active) document.getElementById('statusBuffer').innerText = "";
    if(active) s.classList.add('active'); else s.classList.remove('active');
}

function playTone(f, t, d) {
    const o=ctx.createOscillator(), g=ctx.createGain();
    o.frequency.value=f; 
    g.gain.setValueAtTime(0,t); 
    g.gain.linearRampToValueAtTime(0.5,t+0.01); 
    g.gain.linearRampToValueAtTime(0,t+d-0.01); 
    g.gain.linearRampToValueAtTime(0,t+d);
    o.connect(g); g.connect(ctx.destination); o.start(t); o.stop(t+d);
}

function getEnergy(f) {
    const n = ctx.sampleRate/2;
    const b = Math.round(f / (n/micAnalyser.frequencyBinCount));
    const d = new Uint8Array(micAnalyser.frequencyBinCount);
    micAnalyser.getByteFrequencyData(d);
    // Simple averaging of neighbors for stability
    return (d[b-1] + d[b] + d[b+1]) / 3;
}

function drawViz() {
    const c=document.getElementById('viz'), cc=c.getContext('2d'); c.width=window.innerWidth;
    const d=new Uint8Array(micAnalyser.frequencyBinCount);
    function l() { requestAnimationFrame(l); micAnalyser.getByteFrequencyData(d); cc.clearRect(0,0,c.width,c.height);
        // Zoom into 17k-20k range
        const startBin = Math.floor(17000/(ctx.sampleRate/2/CFG.fft));
        const endBin = Math.floor(20000/(ctx.sampleRate/2/CFG.fft));
        const slice = d.slice(startBin, endBin);
        const w = c.width / slice.length;
        
        cc.fillStyle='#000'; 
        for(let i=0;i<slice.length;i++) {
            if(slice[i]>10) cc.fillRect(i*w, 0, w+1, slice[i]/5);
        }
    } l();
}
</script>
</body>
</html>